# 进程间通信

[TOC]

IPC（Inter-Process Communication），进程间通信，指两个进程的数据之间产生交互



注意进程同步是一种目的，而进程通信是一种手段，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息



## 管道pipe

管道包括三种:

- 普通管道PIPE： 通常有两种限制,一是单工==（只能一个方向传输）==,只能单向传输;二是只能在父子或者兄弟进程间使用.

- 流管道s_pipe: 去除了第一种限制,为半双工==（可以两个方向传输，但是不能同时传输）==，只能在父子或兄弟进程间使用，可以双向传输.

- 命名管道:name_pipe：去除了第二种限制,可以在许多**并不相关的进程**之间进行通讯.

管道都是将数据写了在内核中的缓存，读取也需要通过内核。另外==遵循先进先出原则==。





## 消息队列

- 消息队列是由消息的链表，存放在==内核==中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。每个数据块被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。我们可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。



使用消息队列进行进程间通信，可能会受到数据块最大长度的限制约束等，消息队列通信的速度不是最及时的，毕竟**每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程**。如果频繁的发生进程间的通信行为，那么进程需要频繁地读取队列中的数据到内存，相当于间接地从一个进程拷贝到另一个进程，这需要花费时间。



**特点**

- **消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识**

- **消息队列允许一个或多个进程向它写入与读取消息**

- **管道和命名管道都是通信数据都是先进先出的原则**

- **消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势**



##  信号量

- 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。

- 它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。

- 因此，主要作为进程间以及同一进程内不同线程之间的同步手段。



**信号量不仅可以实现访问的互斥性，还可以实现进程间的同步**，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 **P 操作和 V 操作**。



## 信号

信号是进程间通信机制中**唯一的异步通信机制**，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，**进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号**。有两个信号是应用进程无法捕捉和忽略的，即 `SIGKILL` 和 `SEGSTOP`，这是为了方便我们能在任何时候结束或停止某个进程。





## 共享内存

允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。

由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的**同步及互斥**，这也是带来的问题

多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。



## 套接字

与其它通信机制不同的是，它可用于不同机器间的进程通信。

 简单的说就是通信的两⽅的⼀种约定，⽤套接字中的相关函数来完成通信过程。





# 线程间通信

同个进程下的线程之间都是**共享进程的资源**，只要是**共享变量**都可以做到线程间通信，比如全局变量，所以对于线程间关注的不是通信方式，而是关注多线程竞争共享资源的问题，信号量也同样可以在线程间实现互斥与同步：

- 互斥的方式，可保证任意时刻只有一个线程访问共享资源；
- 同步的方式，可保证线程 A 应在线程 B 之前执行；



## volatile

> volatile语义保证线程可见性有两个原则保证
>
> - 所有volatile修饰的变量一旦被某个线程更改，必须立即刷新到主内存
> - 所有volatile修饰的变量在使用之前必须重新读取主内存的值



## 等待/通知机制（wait()、notify()）

> 在一个线程内调用该线程锁对象的wait方法，线程将进入等待队列进行等待直到被通知或者被唤醒。





## join方式

> join其实合理理解成是线程合并，当在一个线程调用另一个线程的join方法时，当前线程阻塞等待被调用join方法的线程执行完毕才能继续执行，所以join的好处**能够保证线程的执行顺序**，但是如果调用线程的join方法其实已经失去了并行的意义，虽然存在多个线程，但是本质上还是串行的，最后join的实现其实是基于等待通知机制的。





## threadLocal

> threadLocal方式的线程通信，不像以上三种方式是多个线程之间的通信，它更像是一个线程内部的通信，将当前线程和一个map绑定，在当前线程内可以任意存取数据，减省了方法调用间参数的传递。
