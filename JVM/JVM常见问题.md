# JVM常见问题



### 可达性算法不可达的对象就一定会被回收吗？

不一定，当发现对象不可达的时候，将会对此对象进行**第一次标记**，对标记的对象进行筛选，筛选的条件是 **是否有必要执行finalize()方法。**
 当此对象已经调用过finalize()方法或者在对象中没有覆盖finalize()方法，则判定次对象没有必要执行finalize()方法。
 **没有必要执行finalize()方法的对象将会直接被回收。**
 有必要执行finalize()方法的对象放在一个**队列**中，之后有虚拟机创建一个低优先级的线程去出发队列中的对象的finalize()方法，注意此处为触发并非等待finalize()执行结束，防止finalize()方法中出现死循环导致回收系统崩溃。
 当一个对象的finalize()方法执行结束后，方法并没有被回收，稍后会对队列中的对象进行二次标记，此时标记的依据是对象是否可达。如果还是不可达，才会将此对象放入即将回收的集合。所以finalize()方法中如果为对象添加引用链，可以拯救此对象。
 注意：每个对象的finalize()方法只会被jvm调用一次，如果一个对象在第一次执行finalize()时候被拯救，在下次执行回收会直接对对象就行回收，将不会调用对象的finalize()方法。



### 方法区中的垃圾回收和无用的类

方法区有垃圾回收，但是回收的效率低。
方法区只要回收废弃的常量和无用的类。
如果没有任何地方对此常量进行引用，则此常量就会被回收。

- (1)java堆中不存在该类的任何实例。
- (2)加载该类的ClassLoader已经被回收。
- (3)该类的class对象没有任何地方被引用。

满足以上三个条件的类可以被回收，而不是和java堆中的对象一样必然会被回收。



### new一个对象的过程



### 对象创建时内存分配的方式

1、指针碰撞，对象需要多大的内存在类加载完成的时候就已经确定，此内存分配方式相当于，将已分配的内存放在放在一边，为分配的内存放在另一边，中间用指针进行隔离，当需要分配内存的时候只需要移动指针即可。
 2、空闲列表，即维护一个列表，记录内存中还没有分配的内存位置。



### GC Root对象及寻找过程

**根节点主要在全局性的引用(常量、类静态属性)和执行上下文(栈帧中的本地变量表)中**。

(1)虚拟机栈的栈帧中引用的对象。
(2)方法区中静态属性引用的对象。
(3)方法区中常量引用的对象。
(4)本地方法栈中jni引用的对象。
枚举根节点时候需要GC停顿，保证分析结果的准确性。

> 使用GCRoot枚举根节点，由于在整个方法区进行枚举会耗费时间。如何解决？

执行准确式GC并不需要检查执行上下文中所有的引用的位置，在Hotspor中通过**OopMap**（**来存放一个对象内什么偏移量上是什么类型的数据**）。



### 什么是安全点

在类加载完成的时候，虚拟机会将对象内什么偏移量什么数据计算出来，在JIT编译的时候，会在一些特定的位置记录下OopMap，记录了执行到该方法的某条指令的时候，栈上和寄存器里哪些位置是引用，每个方法可能会有好多个OopMap，这是根据特定位置来决定的，这个特定位置会把这个方法分会好几块，每一块都有一个OopMap。

这些特定的位置主要在：

1、方法临返回前/调用方法的call指令后

2、循环的末尾

3、可能抛出异常的地方

这些特定的位置也叫**安全点(Safepoint)。**

OopMap虽然可以进行快速准确的Gc Root枚举，但是虚拟机的指令太多，如果为每个指令都生成对应的OopMap会浪费大量的空间，所以虚拟机会在特定的位置生成OopMap，这些特定的位置称作安全点。

所以程序不是在任何时候都能够进行GC，**只有到达安全点才能进行GC**。

#### 安全点如何选点

依据是否能够让程序长时间的运行为特点进行选定，由于每条指令的运行时间都十分短，所以一般选用的点为方法的调用，循环跳转，异常跳转等。

#### 安全区域

安全点解决了GC问题，但是当发生GC的时候线程处于sleep状态，此时线程无法响应中断请求。此时需要使用安全区域进行解决。安**全区域就是代码片段中引用关系不会发生变化的地方**。当线程执行到安全区域的时候，会对线程进行标记，发生GC时候，jvm不管这些线程，在GC的时候，如果这些线程要离开安全区域，此时，判断jvm是否已经完成GC，如果完成，则线程执行，如果没有完成，则线程停顿等待GC完成的信号。（当线程发生sleep时正处于安全区域）





### 内存泄漏的8中情况

1. **静态集合类**

   > 如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与程序一致，则**容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏**。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。

2. **各种连接，如数据库连接、网络连接和IO连接等**

   > 在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。**只有连接被关闭后，垃圾回收器才会回收对应的对象**。否则，如果在访问数据库的过程中，对Connection、Statement或ResultSet不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。

3. **变量不合理的作用域**

   > 一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生。

4. **内部类持有外部类**

   > 如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。

5. **改变哈希值**

   > 当一个对象被存储进HashSet集合中以后，就**不能修改这个对象中的那些参与计算哈希值的字段了**，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会**导致无法从HashSet集合中单独删除当前对象**，造成内存泄露

6. **缓存泄漏**

   > 一旦你把对象引用放入到缓存中，他就很容易遗忘，对于这个问题，可以使用WeakHashMap代表缓存，此种Map的特点是，当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值

7. **监听器和回调**

   > 如果客户端在你实现的API中注册回调，**却没有显示的取消**，那么就会积聚。需要确保回调立即被当作垃圾回收的最佳方法是只保存他的弱引用，例如将他们保存成为WeakHashMap中的键。

