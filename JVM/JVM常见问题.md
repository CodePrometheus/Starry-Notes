# JVM常见问题



### 可达性算法不可达的对象就一定会被回收吗？

不一定，当发现对象不可达的时候，将会对此对象进行**第一次标记**，对标记的对象进行筛选，筛选的条件是 **是否有必要执行finalize()方法。**
 当此对象已经调用过finalize()方法或者在对象中没有覆盖finalize()方法，则判定次对象没有必要执行finalize()方法。
 **没有必要执行finalize()方法的对象将会直接被回收。**
 有必要执行finalize()方法的对象放在一个**队列**中，之后有虚拟机创建一个低优先级的线程去出发队列中的对象的finalize()方法，注意此处为触发并非等待finalize()执行结束，防止finalize()方法中出现死循环导致回收系统崩溃。
 当一个对象的finalize()方法执行结束后，方法并没有被回收，稍后会对队列中的对象进行二次标记，此时标记的依据是对象是否可达。如果还是不可达，才会将此对象放入即将回收的集合。所以finalize()方法中如果为对象添加引用链，可以拯救此对象。
 注意：每个对象的finalize()方法只会被jvm调用一次，如果一个对象在第一次执行finalize()时候被拯救，在下次执行回收会直接对对象就行回收，将不会调用对象的finalize()方法。



### 方法区中的垃圾回收和无用的类

方法区有垃圾回收，但是回收的效率低。
方法区只要回收废弃的常量和无用的类。
如果没有任何地方对此常量进行引用，则此常量就会被回收。

- (1)java堆中不存在该类的任何实例。
- (2)加载该类的ClassLoader已经被回收。
- (3)该类的class对象没有任何地方被引用。

满足以上三个条件的类可以被回收，而不是和java堆中的对象一样必然会被回收。



### new一个对象的过程



### 对象创建时内存分配的方式

1、指针碰撞，对象需要多大的内存在类加载完成的时候就已经确定，此内存分配方式相当于，将已分配的内存放在放在一边，为分配的内存放在另一边，中间用指针进行隔离，当需要分配内存的时候只需要移动指针即可。
 2、空闲列表，即维护一个列表，记录内存中还没有分配的内存位置。



### GC Root对象及寻找过程

**根节点主要在全局性的引用(常量、类静态属性)和执行上下文(栈帧中的本地变量表)中**。

(1)虚拟机栈的栈帧中引用的对象。
(2)方法区中静态属性引用的对象。
(3)方法区中常量引用的对象。
(4)本地方法栈中jni引用的对象。
枚举根节点时候需要GC停顿，保证分析结果的准确性。

> 使用GCRoot枚举根节点，由于在整个方法区进行枚举会耗费时间。如何解决？

执行准确式GC并不需要检查执行上下文中所有的引用的位置，在Hotspor中通过**OopMap**（**来存放一个对象内什么偏移量上是什么类型的数据**）。



### 什么是安全点

在类加载完成的时候，虚拟机会将对象内什么偏移量什么数据计算出来，在JIT编译的时候，会在一些特定的位置记录下OopMap，记录了执行到该方法的某条指令的时候，栈上和寄存器里哪些位置是引用，每个方法可能会有好多个OopMap，这是根据特定位置来决定的，这个特定位置会把这个方法分会好几块，每一块都有一个OopMap。

这些特定的位置主要在：

1、方法临返回前/调用方法的call指令后

2、循环的末尾

3、可能抛出异常的地方

这些特定的位置也叫**安全点(Safepoint)。**

OopMap虽然可以进行快速准确的Gc Root枚举，但是虚拟机的指令太多，如果为每个指令都生成对应的OopMap会浪费大量的空间，所以虚拟机会在特定的位置生成OopMap，这些特定的位置称作安全点。

所以程序不是在任何时候都能够进行GC，**只有到达安全点才能进行GC**。

#### 安全点如何选点

依据是否能够让程序长时间的运行为特点进行选定，由于每条指令的运行时间都十分短，所以一般选用的点为方法的调用，循环跳转，异常跳转等。

#### 安全区域

安全点解决了GC问题，但是当发生GC的时候线程处于sleep状态，此时线程无法响应中断请求。此时需要使用安全区域进行解决。安**全区域就是代码片段中引用关系不会发生变化的地方**。当线程执行到安全区域的时候，会对线程进行标记，发生GC时候，jvm不管这些线程，在GC的时候，如果这些线程要离开安全区域，此时，判断jvm是否已经完成GC，如果完成，则线程执行，如果没有完成，则线程停顿等待GC完成的信号。（当线程发生sleep时正处于安全区域）

