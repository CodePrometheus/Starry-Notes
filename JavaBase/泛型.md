# 泛型

[TOC]



## 概念

我们的集合可以存储多种数据类型的元素,那么在存储的时候没有任何问题,但是在获取元素,并向下转型的时候,可能会存在一个错误,而这个错误ClassCastException

很显然，集合的这种可以存储多种数据类型的元素的这个特点，不怎么友好，程序存在一些安全隐患,那么为了出来这种安全隐患,我们应该**限定一个集合存储元素的数据类型**,我们只让他存储统一中数据类型的元素,那么在做向下转型的是就不会存在这种安全隐患了. 怎么限定集合只能给我存储同一种数据类型的元素呢? 需要使用泛型

>- 是一种把类型明确的工作推迟到创建对象或者调用方法的时候才去明确的特殊的类型。参数化类型，把类型当作参数一样的传递。
>- 泛型的出现减少了很多强转的操作，同时避免了很多运行时的错误，在编译期完成检查类型转化
>- 泛型是对Java语言类型系统的一种拓展，类似于C++的模板，可以把类型参数看作是使用参数化类型时指定的类型的一个占位符
>- 泛型除了能进行编译器类型检查和规避类型强制转换外，还能有效地提高代码的可读性。如果不使用泛型，当一个不清楚业务场景的人在对集合进行操作时，无法知道list中存储的是什么类型的对象，如果使用了泛型，就能够通过其类型参数判断出当前的业务场景，也增加了代码的可读性，同时也可以大胆地在抽象继承的基础上进行开发了
>- 泛型使用上的灵活性体现在很多方面，因为它本身实质上就是对于继承在使用上的一种增强。因为泛型在具体工作时，当编译器在编译源码的时候，首先要进行泛型类型参数的检查，检查出类型不匹配等问题，然后进行类型擦除并同时在类型参数出现的位置插入强制转换指令，从而实现泛型

格式：`<数据类型>`（这里的数据类型只能是引用数据类型）  `<数据类型1,数据类型2>`





## 使用

```java
//泛型类
public class 类名<泛型类型1,...>//泛型类型必须是引用类型
    
//泛型方法   权限修饰符 <泛型> 返回类型 方法名(泛型标识 参数名称) 抛出的异常//可以是静态
public <T> void show(T t){
    //方法体
}    
//注意：方法声明中定义的形参只能在该方法里使用，而接口、类声明中定义的类型形参则可以在整个接口、类中使用。当调用show()方法时，根据传入的实际对象，编译器就会判断出类型形参T所代表的实际类型
```



```java
//泛型接口
//修饰符 interface 接口名<泛型类型>
public interface Inter<T> {
    public abstract void show(T t) ;
}

//子类是泛型类
public class InterImpl<E> implements Inter<E> {
    @Override
    public void show(E t) {
        System.out.println(t);
    }
}

Inter<String> inter = new InterImpl<String>() ;
inter.show("hello") ;
```



```java
//Java也允许在构造器签名中声明类型参数 -> 泛型构造器
public class Person {
    public <T> Person(T t) {
        System.out.println(t);
    }
}

public static void main(String[] args){
    //隐式
    new Person(22);
    //显示，以显式指定的类型参数为准，若不符则编译报错 
    new<String> Person("hello");
}
```



- **泛型的实质：允许在定义接口、类时声明类型形参，类型形参在整个接口、类体内可当成类型使用，几乎所有可使用普通类型的地方都可以使用这种类型形参**
- 当声明泛型类的实例时，传递的类型参数必须是引用类型，不能使用基本类型
- 当创建了带泛型声明的接口、父类之后，可以为该接口创建实现类，或者从该父类派生子类，需要注意：**使用这些接口、父类派生子类时不能再包含类型形参，需要传入具体的类型**
- Java允许在构造器后不需要带完成的泛型信息，只要给出一对尖括号（<>）即可，Java可以推断尖括号里应该是什么泛型信息 如 `ArrayList<Fruit> flist = new ArrayList<>();` 

1）集合接口或集合类都被修改为带泛型的结构，在实例化集合类时，可以指明具体的泛型结构，指明完以后，在集合类或接口中凡是定义类或接口时，内部结构使用到类的泛型的位置，都指定为实例化时的泛型类型；此外，泛型的类型必须是类，不能是基本数据类型，需要用到基本数据类型的位置，应拿包装类替换

2）实例化时，没有指明泛型的类型，默认类型为java.lang.Object

3）如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象，静态方法中不能使用类的泛型，异常类不能是泛型的

4）父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型

1. 子类不保留父类泛型：按需实现
   - 没有类型 擦除
   - 具体类型
2. 子类保留父类泛型：泛型子类
   - 全部保留
   - 部分保留

```java
class Father<T1,T2>{}
//子类不保留父类泛型
//没有类型 擦除
class Son1<A,B> extends Father {}//等价class Son extends Father<Object,Object>{}
//具体类型
class Son2<A,B> extends Father<Integer,String>{}
//子类保留父类的泛型
//全部保留
class Son3<T1,T2,A,B> extends Father<T1,T2>{}
//部分保留
class Son4<T2,A,B> extends Father<Integer,T2>{}
```







## 通配符

通配符的设计存在一定的场景，例如在使用泛型后，首先声明了一个Animal的类，而后声明了一个继承Animal类的Cat类，显然Cat类是Animal类的子类，但是List却不是List的子类型，而在程序中往往需要表达这样的逻辑关系。为了解决这种类似的场景，在泛型的参数类型的基础上新增了通配符的用法



### 上界通配符

`<? extends T>`表示的是类型的上界(**包含自身**)，因此通配的参数化类型可能是T或T的子类 （<=）

```java 
//它表示集合中的所有元素都是Animal类型或者其子类
List<? extends Animal>
    
//使用关键字extends来实现，实例化时，指定类型实参只能是extends后类型的子类或其本身
//Cat是其子类
List<? extends Animal> list = new ArrayList<Cat>();    
```



### 下界通配符

`<? super T>`表示的是参数化类型是T的超类型（**包含自身**），层层至上，直至Object   （>=）

```java
//它表示集合中的所有元素都是Cat类型或者其父类
List <? super Cat>
    
//Shape是其父类
//使用关键字super来实现，实例化时，指定类型实参只能是extends后类型的子类或其本身
List<? super Cat> list = new ArrayList<Animal>();
```



### 无界通配符

`<?>`，?代表了任何的一种类型，能代表任何一种类型的只有null（Object本身也算是一种类型，但却不能代表任何一种类型，所以List和List的含义是不同的，前者类型是Object，也就是继承树的最上层，而后者的类型完全是未知的）