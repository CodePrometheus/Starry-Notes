## 面向对象

[TOC]



### 类

****

构造对象的模板或蓝图，类**构造**（construct) **对象**的过程称为创建类的**实例** （instance )。

**封装**（ encapsulation , 有时称为数据隐藏） 是与对象有关的一个重要概念。从形式上看， 封装不过是将数据和行为组合在一个包中， 并对对象的使用者隐藏了数据的实现方式。

实现封装的关键在于绝对不能让类中的方法直接地访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。封装给对象赋予了“ 黑盒” 特征， 这是提高重用性和可靠性的关键。

对象中的数据称为**实例域**（ instance field ), 操纵数据的过程称为**方法**（ method) 对于每个特定的类实例（对象）都有一组特定的实例域值。这些值的集合就是这个对象的当前**状态**（ state )。 无论何时，只要向对象发送一个消息，它的状态就有可能发生改变。duixiang

在扩展一个已有的类时， 这个扩展后的新类具有所扩展的类的全部属性和方法。在新类 中，只需提供适用于这个新类的新方法和数据域就可以了。通过扩展一个类来建立另外一个 类的过程称为**继承**（inheritance）

```java
//类的声明
[权限修饰符] [abstract|final] class 类名   //class表明其后声明的是一个类，final表示该类为终结类，不能被继承；abstract为抽象类
[extends 父类名称]                               //表示该类继承的父类
[implements 接口名称列表]{                  //表明该类要实现的接口
       数据成员声明及初始化；
       方法声明及方法体；    
}
```



>类之间的关系：
>
>-  依赖（“ uses-a”） 尽可能让类之间的耦合度最小
>-  聚合（“ has-a”） 包含
>-  继承（“ is-a”）  特殊与一般的关系



#### 抽象类

格式：==权限修饰符 abstract class 类名{…}==

Java中，所有对象都是通过类来描绘的，但并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类，抽象类中一定有构造器，便于子类实例化使用；

抽象来除了不能实例化对象之外（无法使用new关键字），类的其它功能依然存在，成员变量、成员方法、初始化块和构造方法和普通类一样。由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。

>  **抽象方法** 格式：==权限修饰符 abstract 返回值类型 方法名(参数列表);==
>
> 包含抽象方法的类，一定是一个抽象类，抽象类可以没有抽象方法
>
> 若子类重写了父类中所有的抽象方法后，此子类方可实例化，若没有，则子类也是一个抽象类，需要使用abstract修饰

```markdown
abstract不能用来修饰：属性、构造器、私有方法、静态方法、final方法及类
```



#### 内部类

Java中，允许一个类声明在另一个类的内部，前者称为内部类，后者称为外部类

分类 ： 	成员内部类(静态，非静态)  		局部内部类(方法内，代码块内，构造器内)



**成员内部类**

> 1. 作为一个类
>    - 类内可以定义属性、方法、构造器等
>    - 可以被final修饰，不能被继承
>    - 可以被abstract修饰，不能被实例化
> 2. 作为外部类的成员
>    - 调用外部类的结构
>    - 可以被static，public，private，protected，default修饰



```java
class Person{    
    public void eat(){}
    static class Dog{}//静态成员内部类
    class Bird{}//非静态成员内部类
}
	Person.Dog dog = new Person.Dog();//创建实例
	Person p = new Person();//用上行则错误
	Person.Bird bird = p.new Bird();
```



**匿名内部类**

即没有名字的内部类

> 匿名内部类不能定义任何静态成员、方法;
>
> 匿名内部类因为没有类名，可知**匿名内部类不能定义构造器**;
>
> 匿名内部类中的方法不能是抽象的,**必须实现接口或抽象父类的所有抽象方法**
>
> 匿名内部类会继承一个父类（有且只有一个）或实现一个接口（有且只有一个），实现父类或接口中所有抽象方法，可以改写父类中的方法，添加自定义方法;
>
> 当匿名内部类和外部类有同名变量（方法）时，默认访问的是匿名内部类的变量（方法），要访问外部类的变量（方法）则需要**加上外部类的类名**;
>
> 匿名内部类访问的外部类成员变量或成员方法必须用static修饰；
>
> 
>
> (1)、匿名内部类可以访问外部内的所有成员,**内部类可以访问外部类私有变量和方法**
>
> (2)、匿名内部类不能访问外部类未加final修饰的变量（注意：JDK1.8即使没有用final修饰也可以访问）；
>
> (3)、属性屏蔽，与内嵌类相同，匿名内部类定义的类型（如变量）会屏蔽其作用域范围内的其他同名类型（变量）;
>
> (4)、匿名内部类中不能定义静态属性、方法；　　
>
> (5)、匿名内部类可以有常量属性（final修饰的属性）；
>
> (6)、匿名内部内中可以定义属性，如:private int x = 1;
>
> (7)、匿名内部内中可以可以有额外的方法（父接口、类中没有的方法）;
>
> (8)、匿名内部内中可以定义内部类；
>
> (9)、匿名内部内中可以对其他类进行实例化。





### 对象

----

三个主要特性：

- 对象的行为（behavior) —可以对对象施加哪些操作，或可以对对象施加哪些方法
- 对象的状态（state ) —当施加那些方法时，对象如何响应
- 对象标识（identity ) —如何辨别具有相同行为与状态的不同对象

此外，每个对象都保存着描述当前特征的信息，这就是对象的**状态**。对象的状态可能会随着时间而发生改变，但这种改变不会是自发的。对象状态的改变**必须通过调用方法实现**。



#### 构造器

>要想使用对象，就必须首先**构造对象**，并指定其**初始状态**。然后，对对象应用**方法**。故其作用为**创建对象以及初始化对象的信息**
>
>格式： ==权限修饰符 类名 (形参列表) {…}==
>
>Java中，使用构造器构造新实例，**构造器**（constructor）是一种**特殊的方法**，没有返回值，没有void，用来构造并初始化对象，可以有0个、1个或多个参数，**总是伴随着new操作一起调用**，**构造器名称与类名相同**,不需要符合首字母小写的编程风格。

```java
class Rock {
    Rock() { // 这是一个构造器 默认提供的
        System.out.print("Rock ");//Rock Rock Rock Rock Rock Rock Rock Rock Rock Rock 
    }
}

public class SimpleConstructor {
    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Rock();
        }
    }//当创建一个对象时：new Rock() ，内存被分配，构造器被调用。构造器保证了对象在你使用它之前进行了正确的初始化。
}
```

>通常,希望构造的对象可以多次使用,需要将对象存放在一个变量中
>
>Date birthday = new Date();   对象变量birthday。
>
>表达式 new Date() 构造了一个 Date 类型的对象， 并且它的值是对新创建对象的引用。这个引用存储在变量 birthday 中。
>
>一个对象变量并没有实际包含一个对象，而**仅仅引用一个对象**。
>
>任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new 操作符的**返回值也是一个引用**。



1. 如果没有显式的定义类的构造器，则系统默认提供一个空参的构造器
2. 一个类中有多个构造器，在一个构造器中调用另一个构造器，可通过 **this** 关键字实现这样的调用
3. 如果在构造器中没有给域赋予初值，那么就会被自动地赋为默认值：数值为0、布尔值false、对象引用为null。






#### 重载

在同一个类中，允许存在一个以上的同名方法，只要他们的**参数个数或者参数类型不同**即可（参数列表）**两同一不同**（也即一个类中定义的多个构造器，彼此构成重载）

如果**多个方法有相同的名字、不同的参数**，便产生了重载(overloading)。

是否是重载与方法的权限修饰符、返回值类型、形参变量名和方法体**均无任何关系**。

Java 允许**重载任何方法**，而不只是构造器方法。因此，要完整地描述一个方法， 需要指出方法名以及参数类型。这叫做方法的签名（signature)。返回类型不是方法签名的一部分，也即不能有两个名字相同、 参数类型也相同却返回不同类型值的方法。



### 方法

----

>属性 = 成员变量 = field = 域、字段
>
>方法 = 成员方法 = 函数 = method
>
>创建类的对象 = 类的实例化 = 实例化类



方法用于操作对象以及存取它们的实例域。

方法的声明： ==权限修饰符 返回值类型 方法名 (形参列表) {方法体}==

```java
public String getNation(String nation){} //有返回值, 必须在方法声明时, 指定返回值的类型, 方法中return来返回指定类型的数据
public void eat(){}//无返回值，return则表示结束此方法的意思
```

隐式(implicit)参数,是出现在方法名前的类对象。在每一个方法中， 关键字 **this 表示隐式参数**。

显式(explicit)参数 (有些人把隐式参数称为方法调用的目标或接收者)位于方法名后面括号中的数值，显式参数是明显地列在方法声明中的。



#### this关键字

- 可以调用的结构：属性、方法、构造器

  1. 调用属性、方法：this及当前对象 或 当前正在创建的对象

  在类的方法或构造器中，使用 `this.属性`或 `this.方法` 的形式，调用当前(或当前正在创建)的对象属性或方法，通常省略this，但是，如果出现同名，则必须显式的使用 `this.变量` ,以表明此变量是属性，而非形参；

  ​	 2.调用构造器：在类的构造器中，显式的使用 `this(形参列表)`,调用本类中指定的其他构造器，且该显式使用必须声明在当前构造器的首行。





#### static关键字

当编写一个类时，其实就是在描述其对象的属性和行为，而并没有产生实际上的对象，只有通过new关键字才会产生出对象，这时系统才会分配内存空间给对象，其方法才可以供外部调用

static可以用来修饰：<u>属性、方法、代码块、内部类</u> ，不可修饰构造器

注意，static 属于类所有，即由该类创建的所有对象共享同一个 static 属性，也就是说，比如同一个类创建的两个实例对象，static  的方法和属性是共享的

> 1. 修饰属性：静态变量  ->  创建类的多个对象时，多个对象共享同一个静态变量，如当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，为改后的值
>
>      		非静态变量（即实例变量 -> 创建类的多个对象时，每个对象都独立拥有一套类中的非静态变量，当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改）
>
>    - 静态变量随着类的加载而加载（通过 `类.静态变量` 的方式进行调用）,且静态变量的加载要早于对象的创建
>    - 由于类只会加载一次，则静态变量在内存也只会存在一份，存在方法区的静态域中
>    - **无法通过类调用实例变量**
>
> 2. 修饰方法：静态方法
>
>    -  随着类的加载而加载，可以通过 `类.静态方法` 的方式进行调用
>    -  **无法通过类调用非静态方法**
>    -  静态方法中，<u>只能</u> 调用静态的方法或属性
>    -  非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性
>    -  此外，在静态方法中，<u>不能</u>使用 super 及 this



**静态域**

如果将域定义为 static, 每个类中**只有一个**这样的域，而每一个对象对于所有的实例域却都有自己的一份拷贝，其属于类，而不属于任何独立的对象，静态域也被称为类域。



**静态方法**

静态方法是一种不能向对象实施操作的方法，但是，静态方法可以访问自身类中的静态域，静态方法是没有this参数的方法。通常，操作静态属性、工具类中的方法等习惯设置为static，*如Math,Arrays,Collections*



**代码块**

用来初始化类、对象，若有修饰，只能用static

> 静态代码块 -> 内部可以有输出语句，随着类的加载而执行，且只执行一次，如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行；优先于非静态代码块执行；静态代码块内<u>只能调用静态的属性、静态的方法</u>，不能调用非静态的结构
>
> 非静态代码块 -> 内部可以有输出语句，随着对象的创建而执行，每创建一个对象，就执行一次非静态代码块，此外，还可以在创建对象时，对对象的属性等进行初始化；同样多个按照声明的先后顺序；非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法



#### final关键字

final(最终的)可以用来修饰 -> 类、方法、变量 

> - 修饰类：此类不能被继承，如String、System类
> - 修饰方法：此方法不能被重写
> - 修饰变量：此变量称为常量 （static final 用来修饰全局常量）
>   - 修饰属性：可赋值的位置 -> 显式初始化、代码块中初始化、构造器中初始化
>   - 修饰局部变量：当修饰形参时，表明此形参是一个常量，调用此方法时，给常量形参赋一个实参，一旦赋值后，就只能在方法体内使用此形参，但不能重新赋值





#### 方法参数

- 基本数据类型（数字、布尔值）
- 引用数据类型

形参列表：数据类型1 形参1，数据类型2 形参2，…



值调用(call by value) 表示方法接收的是调用者提供的**值**

引用调用(call by reference)表示方法接受的是调用者提供的**变量地址**

方法得到的是所有参数值的一个拷贝，一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）；一个方法可以改变一个对象参数的状态；一个方法不能让对象参数引用一个新的对象。



#### 重写

在子类中可以根据需要对从父类中继承来的方法进行改造，执行时，子类的方法覆盖父类的方法（@override）

```java
权限修饰符 返回值类型 方法名（形参列表）throws 异常类型{
    	方法体
}
```

>1. 子类重写的方法**必须**和父类被重写的方法具有相同的**方法名、参数列表**
>2. 子类重写的方法的**返回值类型不能大于父类**被重写的方法的返回值类型
>   - 被重写方法的返回值类型是void，则重写的只能是void
>   - 被重写方法的返回值类型是A类，则重写的只能是A类或A类的子类
>   - 被重写方法的返回值类型是基本数据类型，则重写的必须是**相同的**基本数据类型
>3. 子类重写的方法使用的**访问权限不能小于父类**被重写的方法的访问权限，此外子类不能重写父类中声明为private的方法
>4. 子类与父类**同名同参数**的方法**必须同时声明为非static**(即为重写)，或者同时声明为static(即不是重写),因为static方法是属于类的，子类无法覆盖父类的方法
>5. 子类重写的方法抛出的**异常类型不大于父类**被重写的方法抛出的异常类型



从**编译和运行**的角度来看重载和重写的不同

- 对于重载而言，在方法调用之前，编译器就以及确定了所要调用的方法，称早绑定或静态绑定。编译器根据方法不同的参数表，对同名方法的名称做修饰，对编译器而言，这些同名方法就成了不同的方法，**它们的调用地址在编译其就绑定了**，Java重载是可以包括父类和子类的，子类可以重载父类的同名不同参数的方法，重载不表现为多态性
- 对于重写而言，只有等到**方法调用**的那一刻，编译器才会确定所要调用的具体方法



### 封装

----

>体现：
>
>- 将类的属性私有化(private)，同时提供公共的(public)方法来获取此属性的值
>- 不对外暴露私有的方法
>- 单例模式（将构造器私有化）
>- 不希望类在包外被调用，可以将类设置为缺省的

权限从小到大：`private<缺省<protected<public`

四种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类

修饰class只能使用：缺省(default)->只能被同一个包内部的类访问、public->能在任意地方被访问

| 修饰符    | 类内部 | 同一个包 | 不同包的子类 | 同一个工程 |
| :-------- | :----- | -------- | ------------ | ---------- |
| private   | Yes    |          |              |            |
| (缺省)    | Yes    | Yes      |              |            |
| protected | Yes    | Yes      | Yes          |            |
| public    | Yes    | Yes      | Yes          | Yes        |



### 包

----

Java允许使用包(package)将类组织起来，确保类名的唯一性，相同的类放置在不同的包中，就不会产生冲突。包名采用因特网域名以逆序的形式。

一个类可以使用所属包中的所有类以及其他包中的公有类(public class)，类的导入可以直接使用**import**语句。

要想将一个类放人包中，就必须将包的名字放在源文件的开头，包中定义类的代码之前。

>标记为 public 的部分可以被任意的类使用；
>
>标记为 private 的部分只能被定义它们的类使用；
>
>标记为 protected 对本包和所有子类可见；

标记为 private 的部分只能被定义它们的类使用；

标记为 protected 对本包和所有子类可见；

如果没有指定 public 或 private , 这个部分(类、方法或变量)可以被同一个包中的所有方法访问。



### 继承

-----

利用继承，可以基于已存在的类构造一个新类，继承已存在的类就是复用(继承)这些类的方法和域，在此基础上还可以添加一些**新的方法和域**。

关键字**extends**表明正在构造的新类派生于一个已存在的类。已存在的类称为超类(superclass)、基类(base class) 或父类(parent class); 新类称为子类(subclass)派生类(derived class)或孩子类b(child class)，此外，除java.lang.Object类之外，所有的java类都直接或间接的继承于java.lang.Object类。



>1. 对于父类声明为private的属性与方法，子类继承之后，仍然认为获取了父类中私有结构，只是由于封装性的影响，使得子类不能直接调用父类的结构
>2. 子父类是相对的概念，且不同于子集与集合的关系，Java只支持**单**继承和**多层**继承
>3. 直接、间接父类，子类继承后，就获取了**直接及间接父类中声明的所有属性和方法**





> 为什么是单继承，而接口允许多实现
>
> -> 若为多继承，那么当多个父类中有重复的属性或方法时，子类的调用结果会含糊不清
>
> 但是多个接口中有重复的方法影响不大，因为实现类必须重写接口中的方法，调用的还是实现类中重写的方法，并且接口中，所有属性都是 static final修饰的，即常量，所有static final修饰的变量都在编译时期确定了其值，若在使用时，两个相同的常量值不同，在编译时期就不能通过。





#### super关键字

类似于this，关键字**super**也有两个用途：

- 调用父类的方法
- 调用父类的构造器



> 1. 在子类的方法或构造器中,使用 `super.属性` 或 `super.方法` 显式的调用父类声明的属性与方法,通常情况下省略
> 2. 当子类和父类定义了同名的属性时，在子类中必须显式地使用 `super.属性` 调用父类中声明的属性
> 3. 当子类重写了父类中的方法后，在子类中必须显式地使用 `super.方法` 调用父类中被重写的方法
>
> - 在子类的构造器中显式地使用 `super(形参列表)` 调用父类中声明的指定的构造器，且其必须声明在子类构造器的**首行**
> - 在类的构造器中 `this.(形参列表)` 或 `super(形参列表)` **只能二选一**，如果都没有，默认为super();



类中的特定方法也可以被声明为 **final**，如果这样做，子类就不能覆盖这个方法(final类中的所有方法自动地成为 final 方法)



#### 多态

一个对象变量可以指示多种实际类型的现象被称为多态(polymorphism),在运行时能够自动地选择调用哪个方法的现象称为动态绑定，**多态为运行时行为**。

一个对象变量既可以引用一个类对象，也可以引用一个类的任何一个子类的对象。

> 体现在对象的多态性：父类的引用指向子类的对象  -> 可以直接应用在抽象类和接口上
>
> Java引用变量有两个类型：编译时类型和运行时类型。 编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定，也即编译时，看左边；运行时，看右边
>
> - 若编译时类型和运行时类型不一致，就出现对象的多态性
>
> - 多态下，“看左边”：指父类的引用（父类中不具备子类特有的方法）
>
>   ​			 “看右边”：指子类的对象（实际运行的是子类重写父类的方法）



```java
//正常方法调用
Person e = new Person();        Student e = new Student();
e.getInfo();			      e.getInfo();
//虚拟方法调用  （子类中定义了与父类同名同参数的方法，多态下，将此时父类的方法称为虚拟方法）
Person e = new Student();//编译时e为Person类型，方法调用是运行时确定的
e.getInfo();  //调用Student类的getInfo()方法
```



#### 向下转型

有了对象的多态性后，内存中实际上是加载了子类特有的属性和方法的，但由于变量声明为父类类型，导致编译时只能调用父类中声明的属性和方法，而子类特有的属性和方法不能调用。

  --> 联想强制类型提升，如何才能调用子类特有？父类->子类 向下转型（使用instanceof进行判断），自然向上为多态

```java
//联想精度损失，使用强转时，可能出现ClassCastException的异常
//if ( a instanceof A ) { } 判断对象a是否是类A的实例，是则返回true，如果false，不进行向下转型，程序不执行
// 如果 a instanceof B 也返回true，类B为类A的父类
```

