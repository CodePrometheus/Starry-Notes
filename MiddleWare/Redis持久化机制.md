# Redis持久化机制

[TOC]

![Redis 持久化](images/persistence.png)



## RDB

![](images/IMG_20210606_180150.jpg)

RDB持久化就是把当前进程数据生成快照保存到硬盘里的过程，触发RDB持久化过程分为手动触发和自动触发



### 手动触发

分别对应 save 和 bgsave 

- save 阻塞当前的Redis服务器，直到RDB过程完成为止，线上不建议使用

- bgsave Redis进程执行 fork 操作创建子线程，RDB持久化过程由子进程负责，完成后自动结束，阻塞只发生 fork 阶段，一般时间很短

Redis默认采用的是LZF 算法对生成的RDB文件做压缩处理

---

BG SAVE 是为了解决 SAVE 资源消耗过多的问题（这一句是点出目标）。BG SAVE核心是利用`fork`系统调用，复制出来一个子进程，而后子进程尝试将数据写入文件。这个时候，子进程和主进程是**共享内存的**，当主进程发生写操作，那么就会复制一份内存，这就是所谓的 COW。COW 的核心是利用缺页异常，操作系统在捕捉到缺页异常之后，发现他们共享内存了，就会复制出来一份。

 Java 里面也有一大类数据结构，利用了 COW 这种思想，例如 `CopyOnWriteArrayList`，当里面元素变更的时候，就会复制出来一个新的。它特别适合那种大多数情况只是读，只有小部分可能是写的场景。

如果 Redis 的数据也是读多写少，那么 COW 就很高效。这也是一种典型的空间换取时间策略。



**COW缺点**

1. 引发缺页异常。如果物理内存紧张，还会引起大量的物理页置换；
2. COW 的存在，导致我们需要预留一部分内存出来，Redis 无法全部利用服务器的内存；

一般来说，最极端情况是所有内存复制一遍，那么 Redis 最多利用一半的内存，考虑到操作系统本身的开销，那么一半都不到。不过如果愿意冒险的话，可以设置超过一半。例如，不考虑操作系统开销，如果自己的 Redis 读多写少，在整个 BG SAVE 过程，最多复制 10% 的内存，那么就可以给 Redis 分配 80% 的内存。这种搞法，糟糕的情况下，会引发大量的物理页置换，性能下降。所以，很少有人这么使用。



**优点**

RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照，非常适合用于备份，全量复制等场景

Redis加载RDB恢复数据 远远快于 AOF的方式



**缺点**

RDB方式没有办法做到实时持久化/秒级持久化，fork创建子线程属于重量级操作，

存在老版本Redis服务器无法兼容新版RDB格式问题







## AOF

