# 创建型模式

- 工厂方法
- 抽象工厂
- 建造者
- 单例
- 原型



## 工厂方法

定义工厂父类负责定义创建对象的**公共接口**，而**子类则负责生成具体的对象**。

将类的实例化（具体产品的创建）延迟到工厂类的子类（具体工厂）中完成，即由子类来决定应该实例化（创建）哪一个类。



如jdk源码的iterator，具体由子类去实现





## 抽象工厂

提供一个创建一系列相关或相互依赖对象的接口

无需指定它们具体的类







## 建造者

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示，也即分离对象的属性于创建过程

用户只需指定需要建造的类型就可以得到它们，构建过程及细节不需要知道

适用于一个对象有非常复杂的内部结构（很多属性）

如jdk里的StringBuffer，MyBatis内部大量使用了建造者模式



### 缺点

- 产生多余的Builder对象

  

- 产品内部发生变化，建造者都需要修改，成本较大



### 区别

建造者更注重方法的调用顺序，而工厂方法注重创建产品

此外创建对象的力度也不同，建造者模式创建较为复杂的产品，由各种复杂的组件组成





## 单例

> 多线程中的线程池
>
> 数据库的连接池
>
> 系统环境信息
>
> 上下文（ServletContext）

保证一个类仅有一个实例，并提供一个全局访问点，私有构造器

减少内存开销，避免对资源的多重占用，设置全局访问点，严格控制访问

缺点如没有接口，扩展困难



### 实现

性能和线程安全

1.DoubleCheck双重检查，也即两个if判断，减少synchronized对性能的影响，但是会受指令重排序的影响，可加volatile实现内存可见性，缓存一致性，也可通过静态内部类实现（推荐），基于类初始化的延迟加载解决方案（懒汉式）



2.在类加载时完成初始化，避免线程同步问题（饿汉式）



3.注意序列化和反序列化对单例的破坏，反序列化的时候通过反射newInstance重新生成了一个类，所以和原有的类不是同一个。解决可在单例类中重写一个方法：readResolve 返回单例类底层代码在执行的过程中虽然还会通过反射重新创建单例，但是最终会调用这个方法，从而返回原始的单例 



4.注意反射对单例的破坏，枚举类的单例模式不会被反射破坏



## 原型

指定创建对象的种类，并且通过拷贝这些原型创建新的对象

不需要知道任何创建的细节，不调用构造函数

适用于类初始化消耗较多资源，new产生一个对象需要非常繁琐的过程（数据准备、访问权限等），构造函数比较复杂，循环体中生产大量对象时

缺点 -> 必须配备克隆方法，对克隆复杂对象或克隆出的对象进行复杂改造时，容易引入风险，要注意深、浅克隆













