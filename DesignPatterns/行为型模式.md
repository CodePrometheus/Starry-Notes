# 行为型模式

- 观察者
- 访问者
- 迭代器
- 责任链
- 备忘录
- 解释器
- 策略
- 模板方法
- 命令
- 状态
- 中介者



## 观察者

定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

**模式缺点** : 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。





## 访问者

 主要将数据结构与数据操作分离。

使用场景 : 作用于一个数据结构之上的操作经常变化





## 迭代器

提供一种方法，顺序访问一个集合对象中的各个元素，而又不暴漏该对象的内部表示

为遍历不同的集合结构提供一个统一的接口



## 责任链

为请求创建一个接受此次请求对象的链

如校验权限的chain，filter





## 备忘录

在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。

 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2、实现了信息的封装，使得用户不需要关心状态的保存细节。

使用场景 : 1、需要保存/恢复数据的相关状态场景。 2、提供一个可回滚的操作。





## 解释器

为了解释一种语言，而为语言创建的解释器

**使用场景** : 1、可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 2、一些重复出现的问题可以用一种简单的语言来进行表达。 3、一个简单语法需要解释的场景。



## 策略

定义了算法家族，分别封装起来，让它们之间可以互相替换，让算法的变化不会影响到适用算法的用户

解决出现大量if else的问题



## 模板方法

定义一个算法的骨架，并允许子类为一个或多个步骤提供实现，模板方法是得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤

适用场景：一次性实现一个算法的不变的部分，并将可变的行为留给子类实现，各子类中公共的行为被提取出来并集中到一个公共父类中，从而避免代码重复

模板方法模式中分为两大类：模版方法和基本方法，而基本方法又分为：抽象方法，具体方法，钩子方法。



## 命令

将一个请求封装成一个对象，从而可以用不同的请求对客户进行参数化。

解决程序中对象的职责以及它们之间的通信方式

使用场景 : 行为的请求者与行为的处理者耦合度过高。





## 状态

允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类

使用场景 : 一个对象在多个状态下行为不同，且这些状态可互相转换

通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if...else 等条件选择语句。





## 中介者

用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

使用场景 : 一个系列的对象交互关系十分复杂。
1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类











