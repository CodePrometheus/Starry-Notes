# 三握四挥

[TOC]

## 三次握手过程

客户端——发出连接请求（SYN=1），同时选择一个初始化序列号（seq=x）——服务端 **一次握手** Client进入syn_sent（同步已发送）状态（TCP规定，SYN不能携带数据，但需要消耗掉一个序号）

 服务端——收到请求，同意则发送确认报文（ACK=1，SYN=1，ack=x+1，seq=y）——客户端 **二次握手** 服务端进入syn_rcvd（同步收到）状态

 客户端——像服务器给出确认（ACK=1，seq=x+1，ack=y+1）——服务端 **三次握手** 连接就进入Established（已建立连接）状态（TCP规定，ACK可以携带数据，但是不携带则不消耗序号）![这里写图片描述](images/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA3MjA1NzA5MzY3)

![三次握手](images/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA1MTEwNDA1NjY2)





## 四次挥手过程

客户端——主动关闭（FIN=1，seq=u）——服务端，关闭与服务端的连接 ，客户端进入FIN-WAIT-1状态（终止等待1）

服务端——发送确认报文（ACK=1，ack=u+1，seq=v）——服务端就进入了CLOSE-WAIT状态（关闭等待）此时客户端处于半关闭状态，如果服务器发送数据，客户端依然要接受

 服务端——（FIN=1，ACK=1，seq=w，ack=u+1）——客户端，关闭与客户端的连接，客户端就进入FIN-WAIT-2状态（终止等待2），服务器进入LAST-ACK（最后确认）状态，等待客户端确认

客户端收到这个 FIN，发回 ACK 报⽂确认，并将确认序号设置为收到序号加1（ACK=1，seq=u+1，ack=w+1），TIME-WAIT（时间等待）状态，注意此时TCP连接还没有释放，必须经过2*MSL（最长报文段寿命）时间后，当客户端撤销响应的TCB后，才进入CLOSED（关闭）状态

服务端只要收到了客户端发出的确认，立即进入CLOSED状态，无需等待，同样撤销TCB后，结束此次TCP连接

![](images/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA3MjA1NzU2MjU1)

![四次挥手](images/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA2MDg0ODUxMjcy)

---

**以下是常见问题**



## 为什么是三次握手

![img](images/20210127161838.png)

两次握手只能保证单向连接是畅通的。只有经过第三次握手，才能确保双向都可以接收到对方的发送的 数据。两次握手接收方这里不能确定自己的的发送是正常的，发送方的接收是正常的。如果第三次握手迟迟不来，服务器就可以认为之间的SYN是无效的，**三次握手的目的是建立可靠的通信信道**



### 为什么不是两次握手

这是为了**避免服务器建立无用连接**（客户端服务器建立连接后，却不传输数据）

如果只进行两次握手，如果客户端向服务器第一次发送的建立连接的请求因为某原因，**兜兜转转绕了一大圈才到达服务器**。这期间客户端因为未收到服务器的响应，就会再次发送连接请求，这时服务器收到了，向客户端发送连接请求后，连接便建立了。然后数据传输完毕后，释放连接。**这时刚刚兜兜转转一大圈的建立连接的请求到了服务器**，服务器收到后再次向客户端发送请求，发送后又建立了连接，但是建立连接后客户端没有再理会服务器，客户端与服务器之间没有传输数据，此时服务器的资源就会被浪费

![img](images/20201208172930.png)



### 为什么四次握手

**因为通信不可能100%可靠**（红军蓝军约定）， 而上面的三次握手已经做好了通信的准备工作， **再增加握手， 并不能显著提高可靠性**，所以只需要三次握手就足够了





## 为什么是四次挥手

![img](images/20201209144349.png)

- 建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，**把ACK和SYN放在一个报文里发送给客户端**

- 关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，**己方ACK和FIN一般都会分开发送，从而导致多了一次，也就是，不能一次性将确认报文和FIN报文发送给客户端**



## 为什么客户端最后还要等待2MSL

**确保第四次挥手服务器能够收到，同时使失效的连接请求从网络中消失**

- **Time-wait存在的意义– 保证客户端发送的最后一个ACK报文能够到达服务器**，因为这个ACK报文可能丢失。站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，**于是服务器又会重新发送一次，一去一回就是2MSL**，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会**重启2MSL计时器**

- 防止类似与三次握手中提到了的**已经失效的连接请求报文段**出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以**使本连接持续的时间内所产生的所有报文段都从网络中消失**（最长生存MSL）。**这样新的连接中不会出现旧连接的请求报文**



## 客户端第一个SYN包丢了，怎么办

客户端会尝试三次重传 SYN 包，间隔时间分别是 5.8s、24s、48s。建立一个新连接的最长时间限制为 75 秒。





## 服务端收到的SYN并回复的[SYN，ACK]包丢了，怎么办

客户端没收到 ACK 会以为是前面 SYN 丢了，尝试重传 SYN 包。
服务器端在超时时间内没有收到客户端发来的「ACK」包，也会触发重传，此时服务端处于 SYN_RCVD 状态，会依次等待 3s、6s、12s 后，重新发送「SYN, ACK」包。不同的操作系统下，重传的次数有不同的配置，比如 linux 默认是 5 。如果重试后还是没有收到，则会断开连接。
同时由于客户端在没有收到「SYN,ACK」时，也会进行重传，当客户端重传的「SYN」收到后，会立即重新发送「SYN,ACK」包。



## 客户端最后一次回复的[ACK]包丢了，怎么办

客户端此时进入 ESTABLISHED 状态。
服务端因为收不到「ACK」会走重传机制，依然处于 SYN-RCVD 状态。如果此时接收到客户端真实发送来的数据包时，通过包内 ACK 的确认序号，会认为连接已建立，并进入 ESTABLISHED 状态。



## SYN泛洪攻击

利用TCP三次握手机制的缺陷，主要发生在OSI的第四层（也就是运输层），第二次握手服务器返回给客户端ACK后，此时客户端不再进行确认，连接就处在一个挂起的状态（半连接），服务器因为收不到再确认的消息，会重复发送ACK给客户端，如果此时大量非法的这种TCP连接发来，每一个都无法完成握手的机制，就会消耗服务器的内存最后导致服务器死机

**解决**：1.降低SYN timeout时间，使得主机尽快释放半连接的占用

2.采用SYN cookie设置，如果短时间内收到了某个IP的重复SYN请求，我们就认为受到了攻击，原理是，在TCP服务器收到TCP SYN包并返回TCP SYN+ACK包时，不分配一个专门的数据区，而是根据这个SYN包计算出一个cookie值。在收到TCP ACK包时，TCP服务器在根据那个cookie值检查这个TCP ACK包的合法性。如果合法，再分配专门的数据区进行处理未来的TCP连接

> **Linux**中的`/proc/sys/net/ipv4/tcp_syncookies`是内核中的`SYN Cookies`开关,`0`表示关闭`SYN Cookies`；`1`表示在新连接压力比较大时启用`SYN Cookies`,`2`表示始终使用`SYN Cookies`。

3.合理的采用防火墙设置等外部网络也可以进行拦截







