# MySQL常见问题

[TOC]



## 分页查询优化

### 最基本的分页方式

~~~mysql
SELECT ... FROM ... WHERE ... ORDER BY ... LIMIT ... 
- **第一个参数**指定第一个返回记录行的**`偏移量`**，**第二个参数**指定**返回记录行的最大数目**，初始记录行的偏移量是 0(而不是 1)
~~~

在中小数据量的情况下，这样的SQL足够用了，唯一需要注意的问题就是确保使用了索引：
举例来说，如果实际SQL类似下面语句，那么在category_id, id两列上建立复合索引比较好

~~~mysql
SELECT * FROM articles WHERE category_id = 123 ORDER BY id LIMIT 50, 10
~~~

### 大数据分页查询优化

1. **使用主键id来优化**

   语句样式1：SELECT * FROM tableName WHERE id_pk > ((pageNum-1) * pageSize) ORDER BY id_pk ASC LIMIT pageSize
   解析：因为依赖主键自增，可直接定位主键偏移量，避免了从头遍历，因此效率非常高。但是只支持升序，不支持降序。

   

   语句样式2：SELECT * FROM tableName WHERE id_pk between 100000 and 10200 ORDER BY id_pk ASC LIMIT pageSize
   解析：照比样式1，就是**确定了主键id的范围，也不需要从头遍历**，效率高。

2. **使用主键id同时使用prepare**

   语句样式：prepare pre_d from 'select * from testpage where tid> (?*?) order by tid limit ?';

3. **使用子查询**

   语法样式：select * from orders_history where id>=(select id from orders_history order by id limit 100000,1) limit 100;

4. 在LIMIT偏移量较大的时候，查询效率会变低，**可以记录每次取出的最大ID，下次查询时可以利用ID进行查询**

5. **建立复合索引**





## 为什么用B+Tree

主要是**为了提升查找效率**

查找数据，最简单的方式是顺序查找。但是对于几十万上百万，甚至上亿的数据库查询就很慢了。

所以要对查找的方式进行优化，熟悉的二分查找，二叉树可以把速度提升到O(log(n,2))，查询的瓶颈在于树的深度，最坏的情况要查找到二叉树的最深层，由于，每查找深一层，就要访问更深一层的索引文件。在多达数G的索引文件中，这将是很大的开销。所以，尽量把数据结构设计的更为‘矮胖’一点就可以减少访问的层数。在众多的解决方案中，B/B+树很好的适合。B树定义具体可以查阅，简而言之就是中间节点可以多余两个子节点，而且中间的元素可以是一个域。相比B树，B+树的父节点也必须存在于子节点中，是其中最大或者最小元素，B+树的节点只存储索引key值，具体信息的地址存在于叶子节点的地址中。这就使以页为单位的索引中可以存放更多的节点。减少更多的I/O支出。因此，B+树成为了数据库比较优秀的数据结构，MySQL中MyIsAM和InnoDB都是采用的B+树结构。不同的是前者是非聚集索引，后者主键是聚集索引，所谓聚集索引是物理地址连续存放的索引，在取区间的时候，查找速度非常快，但同样的，插入的速度也会受到影响而降低。聚集索引的物理位置使用链表来进行存储。

B+树与B树相比，有以下优势：

- **更少的IO次数**：B+树的非叶节点只包含键，而不包含真实数据，因此每个节点存储的记录个数比B数多很多（即阶m更大），因此B+树的高度更低，访问时所需要的IO次数更少。此外，由于每个节点存储的记录数更多，所以对访问局部性原理的利用更好，缓存命中率更高。
- **更适于范围查询**：在B树中进行范围查询时，**首先找到要查找的下限，然后对B树进行中序遍历，直到找到查找的上限**；而B+树的范围查询，只需要对**链表进行遍历**即可。
- 更稳定的查询效率：B树的查询时间复杂度在1到树高之间(分别对应记录在根节点和叶节点)，而B+树的查询复杂度则稳定为树高，因为所有数据都在叶节点。