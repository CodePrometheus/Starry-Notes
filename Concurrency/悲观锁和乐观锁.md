# 悲观锁和乐观锁

[TOC]



## 悲观锁

每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会**阻塞直到它拿到锁**。悲观锁假定当前事务操纵数据资源时，肯定还有其他事务同时访问该数据资源，为了避免当前事务的操作受到干扰，**先锁定资源**。



使用场景 ： 在关系型数据库里，如行锁，表锁，读、写锁等，Java的Synchronized和Lock 接口相关类



### 存在的问题

1. 在多线程竞争下，加锁、释放锁会导致比较多的**上下文切换和调度延时**，引起性能问题。

2. 一个线程持有锁会导致**其它所有需要此锁的线程挂起**。

3. 如果一个优先级高的线程等待一个优先级低的线程释放锁会导致**优先级倒置**，引起性能风险。





## 乐观锁

 乐观锁体现的是悲观锁的反面。它是一种积极的思想，它总是认为数据是不会被修改的，所以是不会对数据上锁的，但是乐观锁在**更新的时候会去判断数据是否被更新过**。乐观锁的实现方案一般有两种（版本号机制和CAS）。乐观锁适用于**读多写少的场景，这样可以提高系统的并发量**。在Java中 **java.util.concurrent.atomic**下的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。

　　乐观锁，大多是基于数据版本 (Version)记录机制实现。即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来 实现。 读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提 交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据 版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。


